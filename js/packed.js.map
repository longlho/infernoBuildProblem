{"version":3,"sources":["webpack:///webpack/bootstrap bc9605ef962aa5748f42","webpack:///./~/inferno/dist/inferno.node.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./~/inferno-component/dist/inferno-component.node.js","webpack:///./src/main.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD;AAChD,CAAC,4BAA4B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,SAAS;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,aAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qCAAqC,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA,2CAA2C,mBAAmB,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,cAAc;;AAE5D,CAAC;;;;;;;;ACr/ED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;AClLtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,SAAS;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;;;;;;;;;;;;;;AC3TD,uCAA8B;AAC9B,iDAA0C;AAE1C,OAAO,CAAC,GAAG,CAAC,2BAAS,CAAC,CAAC;AAEvB;IAA4B,0BAAgB;IAA5C;;IAIA,CAAC;IAHU,uBAAM,GAAb;QACI,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IACL,aAAC;AAAD,CAAC,CAJ2B,2BAAS,GAIpC;AAJY,wBAAM;AAMnB,iBAAO,CAAC,MAAM,CAAC,aAAa,EAAE,QAAQ,CAAC,aAAa,CAAC,gBAAgB,CAAC,CAAC,CAAC","file":"packed.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bc9605ef962aa5748f42","\n/*!\n * Inferno v1.3.0-rc.8\n * (c) 2017 Dominic Gannaway'\n * Released under the MIT License.\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.Inferno = global.Inferno || {})));\n}(this, (function (exports) { 'use strict';\n\nvar NO_OP = '$NO_OP';\nvar ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';\nvar isBrowser = typeof window !== 'undefined' && window.document;\n\n// this is MUCH faster than .constructor === Array and instanceof Array\n// in Node 7 and the later versions of V8, slower in older versions though\nvar isArray = Array.isArray;\nfunction isStatefulComponent(o) {\n    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);\n}\nfunction isStringOrNumber(obj) {\n    var type = typeof obj;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(obj) {\n    return isUndefined(obj) || isNull(obj);\n}\nfunction isInvalid(obj) {\n    return isNull(obj) || obj === false || isTrue(obj) || isUndefined(obj);\n}\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\nfunction isAttrAnEvent(attr) {\n    return attr[0] === 'o' && attr[1] === 'n' && attr.length > 3;\n}\nfunction isString(obj) {\n    return typeof obj === 'string';\n}\nfunction isNumber(obj) {\n    return typeof obj === 'number';\n}\nfunction isNull(obj) {\n    return obj === null;\n}\nfunction isTrue(obj) {\n    return obj === true;\n}\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isObject(o) {\n    return typeof o === 'object';\n}\nfunction throwError(message) {\n    if (!message) {\n        message = ERROR_MSG;\n    }\n    throw new Error((\"Inferno Error: \" + message));\n}\nfunction warning(message) {\n    console.warn(message);\n}\nfunction Lifecycle() {\n    this.listeners = [];\n}\nLifecycle.prototype.addListener = function addListener(callback) {\n    this.listeners.push(callback);\n};\nLifecycle.prototype.trigger = function trigger() {\n    var this$1 = this;\n\n    for (var i = 0, len = this.listeners.length; i < len; i++) {\n        this$1.listeners[i]();\n    }\n};\n\nfunction applyKey(key, vNode) {\n    vNode.key = key;\n    return vNode;\n}\nfunction applyKeyIfMissing(key, vNode) {\n    if (isNumber(key)) {\n        key = \".\" + key;\n    }\n    if (isNull(vNode.key) || vNode.key[0] === '.') {\n        return applyKey(key, vNode);\n    }\n    return vNode;\n}\nfunction applyKeyPrefix(key, vNode) {\n    vNode.key = key + vNode.key;\n    return vNode;\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (var len = nodes.length; index < len; index++) {\n        var n = nodes[index];\n        var key = currentKey + \".\" + index;\n        if (!isInvalid(n)) {\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, key);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n);\n                }\n                else if (isVNode(n) && n.dom || (n.key && n.key[0] === '.')) {\n                    n = cloneVNode(n);\n                }\n                if (isNull(n.key) || n.key[0] === '.') {\n                    n = applyKey(key, n);\n                }\n                else {\n                    n = applyKeyPrefix(currentKey, n);\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction normalizeVNodes(nodes) {\n    var newNodes;\n    // we assign $ which basically means we've flagged this array for future note\n    // if it comes back again, we need to clone it, as people are using it\n    // in an immutable way\n    // tslint:disable\n    if (nodes['$']) {\n        nodes = nodes.slice();\n    }\n    else {\n        nodes['$'] = true;\n    }\n    // tslint:enable\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        var n = nodes[i];\n        if (isInvalid(n) || isArray(n)) {\n            var result = (newNodes || nodes).slice(0, i);\n            _normalizeVNodes(nodes, result, i, \"\");\n            return result;\n        }\n        else if (isStringOrNumber(n)) {\n            if (!newNodes) {\n                newNodes = nodes.slice(0, i);\n            }\n            newNodes.push(applyKeyIfMissing(i, createTextVNode(n)));\n        }\n        else if ((isVNode(n) && n.dom) || (isNull(n.key) && !(n.flags & 64 /* HasNonKeyedChildren */))) {\n            if (!newNodes) {\n                newNodes = nodes.slice(0, i);\n            }\n            newNodes.push(applyKeyIfMissing(i, cloneVNode(n)));\n        }\n        else if (newNodes) {\n            newNodes.push(applyKeyIfMissing(i, cloneVNode(n)));\n        }\n    }\n    return newNodes || nodes;\n}\nfunction normalizeChildren(children) {\n    if (isArray(children)) {\n        return normalizeVNodes(children);\n    }\n    else if (isVNode(children) && children.dom) {\n        return cloneVNode(children);\n    }\n    return children;\n}\nfunction normalizeProps(vNode, props, children) {\n    if (!(vNode.flags & 28 /* Component */) && isNullOrUndef(children) && !isNullOrUndef(props.children)) {\n        vNode.children = props.children;\n    }\n    if (props.ref) {\n        vNode.ref = props.ref;\n        delete props.ref;\n    }\n    if (props.events) {\n        vNode.events = props.events;\n    }\n    if (!isNullOrUndef(props.key)) {\n        vNode.key = props.key;\n        delete props.key;\n    }\n}\nfunction normalizeElement(type, vNode) {\n    if (type === 'svg') {\n        vNode.flags = 128 /* SvgElement */;\n    }\n    else if (type === 'input') {\n        vNode.flags = 512 /* InputElement */;\n    }\n    else if (type === 'select') {\n        vNode.flags = 2048 /* SelectElement */;\n    }\n    else if (type === 'textarea') {\n        vNode.flags = 1024 /* TextareaElement */;\n    }\n    else if (type === 'media') {\n        vNode.flags = 256 /* MediaElement */;\n    }\n    else {\n        vNode.flags = 2 /* HtmlElement */;\n    }\n}\nfunction normalize(vNode) {\n    var props = vNode.props;\n    var hasProps = !isNull(props);\n    var type = vNode.type;\n    var children = vNode.children;\n    // convert a wrongly created type back to element\n    if (isString(type) && (vNode.flags & 28 /* Component */)) {\n        normalizeElement(type, vNode);\n        if (hasProps && props.children) {\n            vNode.children = props.children;\n            children = props.children;\n        }\n    }\n    if (hasProps) {\n        normalizeProps(vNode, props, children);\n    }\n    if (!isInvalid(children)) {\n        vNode.children = normalizeChildren(children);\n    }\n    if (hasProps && !isInvalid(props.children)) {\n        props.children = normalizeChildren(props.children);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        // This code will be stripped out from production CODE\n        // It will help users to track errors in their applications.\n        var verifyKeys = function (vNodes) {\n            var keyValues = vNodes.map(function (vnode) { return vnode.key; });\n            keyValues.some(function (item, idx) {\n                var hasDuplicate = keyValues.indexOf(item) !== idx;\n                if (hasDuplicate) {\n                    warning('Inferno normalisation(...): Encountered two children with same key, all keys must be unique within its siblings. Duplicated key is:' + item);\n                }\n                return hasDuplicate;\n            });\n        };\n        if (vNode.children && Array.isArray(vNode.children)) {\n            verifyKeys(vNode.children);\n        }\n    }\n}\n\nvar options = {\n    recyclingEnabled: false,\n    findDOMNodeEnabled: false,\n    roots: null,\n    createVNode: null,\n    beforeRender: null,\n    afterRender: null,\n    afterMount: null,\n    afterUpdate: null,\n    beforeUnmount: null\n};\n\nfunction createVNode(flags, type, props, children, events, key, ref, noNormalise) {\n    if (flags & 16 /* ComponentUnknown */) {\n        flags = isStatefulComponent(type) ? 4 /* ComponentClass */ : 8 /* ComponentFunction */;\n    }\n    // Primitive node doesn't have defaultProps, only Component\n    if (flags & 28 /* Component */) {\n        // set default props\n        var defaultProps = type.defaultProps;\n        if (!isNullOrUndef(defaultProps)) {\n            props = props || {}; // Create new object if only defaultProps given\n            for (var prop in defaultProps) {\n                if (isUndefined(props[prop])) {\n                    props[prop] = defaultProps[prop];\n                }\n            }\n        }\n    }\n    var vNode = {\n        children: isUndefined(children) ? null : children,\n        dom: null,\n        events: events || null,\n        flags: flags,\n        key: isUndefined(key) ? null : key,\n        props: props || null,\n        ref: ref || null,\n        type: type\n    };\n    if (!noNormalise) {\n        normalize(vNode);\n    }\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    return vNode;\n}\nfunction cloneVNode(vNodeToClone, props) {\n    var arguments$1 = arguments;\n\n    var restParamLength = arguments.length - 2; // children\n    var children;\n    // Manually handle restParam for children, because babel always creates array\n    // Not creating array allows us to fastPath out of recursion\n    if (restParamLength > 0) {\n        if (!props) {\n            props = {};\n        }\n        if (restParamLength === 1) {\n            children = arguments[2];\n        }\n        else {\n            children = [];\n            while (restParamLength-- > 0) {\n                children[restParamLength] = arguments$1[restParamLength + 2];\n            }\n        }\n        if (isUndefined(props.children)) {\n            props.children = children;\n        }\n        else {\n            if (isArray(children)) {\n                if (isArray(props.children)) {\n                    props.children = props.children.concat(children);\n                }\n                else {\n                    props.children = [props.children].concat(children);\n                }\n            }\n            else {\n                if (isArray(props.children)) {\n                    props.children.push(children);\n                }\n                else {\n                    props.children = [props.children];\n                    props.children.push(children);\n                }\n            }\n        }\n    }\n    var newVNode;\n    if (isArray(vNodeToClone)) {\n        var tmpArray = [];\n        for (var i = 0, len = vNodeToClone.length; i < len; i++) {\n            tmpArray.push(cloneVNode(vNodeToClone[i]));\n        }\n        newVNode = tmpArray;\n    }\n    else {\n        var flags = vNodeToClone.flags;\n        var events = vNodeToClone.events || (props && props.events) || null;\n        var key = !isNullOrUndef(vNodeToClone.key) ? vNodeToClone.key : (props ? props.key : null);\n        var ref = vNodeToClone.ref || (props ? props.ref : null);\n        if (flags & 28 /* Component */) {\n            newVNode = createVNode(flags, vNodeToClone.type, Object.assign({}, vNodeToClone.props, props), null, events, key, ref, true);\n            var newProps = newVNode.props;\n            if (newProps) {\n                var newChildren = newProps.children;\n                // we need to also clone component children that are in props\n                // as the children may also have been hoisted\n                if (newChildren) {\n                    if (isArray(newChildren)) {\n                        for (var i$1 = 0, len$1 = newChildren.length; i$1 < len$1; i$1++) {\n                            var child = newChildren[i$1];\n                            if (!isInvalid(child) && isVNode(child)) {\n                                newProps.children[i$1] = cloneVNode(child);\n                            }\n                        }\n                    }\n                    else if (isVNode(newChildren)) {\n                        newProps.children = cloneVNode(newChildren);\n                    }\n                }\n            }\n            newVNode.children = null;\n        }\n        else if (flags & 3970 /* Element */) {\n            children = (props && props.children) || vNodeToClone.children;\n            newVNode = createVNode(flags, vNodeToClone.type, Object.assign({}, vNodeToClone.props, props), children, events, key, ref, !children);\n        }\n        else if (flags & 1 /* Text */) {\n            newVNode = createTextVNode(vNodeToClone.children);\n        }\n    }\n    return newVNode;\n}\nfunction createVoidVNode() {\n    return createVNode(4096 /* Void */);\n}\nfunction createTextVNode(text) {\n    return createVNode(1 /* Text */, null, null, text, null, null, null, true);\n}\nfunction isVNode(o) {\n    return !!o.flags;\n}\n\nfunction linkEvent(data, event) {\n    return { data: data, event: event };\n}\n\nfunction constructDefaults(string, object, value) {\n    /* eslint no-return-assign: 0 */\n    var array = string.split(',');\n    for (var i = 0, len = array.length; i < len; i++) {\n        object[array[i]] = value;\n    }\n}\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar svgNS = 'http://www.w3.org/2000/svg';\nvar strictProps = {};\nvar booleanProps = {};\nvar namespaces = {};\nvar isUnitlessNumber = {};\nvar skipProps = {};\nvar delegatedProps = {};\nconstructDefaults('xlink:href,xlink:arcrole,xlink:actuate,xlink:role,xlink:titlef,xlink:type', namespaces, xlinkNS);\nconstructDefaults('xml:base,xml:lang,xml:space', namespaces, xmlNS);\nconstructDefaults('volume,defaultChecked', strictProps, true);\nconstructDefaults('children,childrenType,defaultValue,ref,key,selected,checked,multiple', skipProps, true);\nconstructDefaults('onClick,onMouseDown,onMouseUp,onMouseMove,onSubmit,onDblClick,onKeyDown,onKeyUp,onKeyPress', delegatedProps, true);\nconstructDefaults('muted,scoped,loop,open,checked,default,capture,disabled,readOnly,required,autoplay,controls,seamless,reversed,allowfullscreen,novalidate,hidden', booleanProps, true);\nconstructDefaults('animationIterationCount,borderImageOutset,borderImageSlice,borderImageWidth,boxFlex,boxFlexGroup,boxOrdinalGroup,columnCount,flex,flexGrow,flexPositive,flexShrink,flexNegative,flexOrder,gridRow,gridColumn,fontWeight,lineClamp,lineHeight,opacity,order,orphans,tabSize,widows,zIndex,zoom,fillOpacity,floodOpacity,stopOpacity,strokeDasharray,strokeDashoffset,strokeMiterlimit,strokeOpacity,strokeWidth,', isUnitlessNumber, true);\n\nvar isiOS = isBrowser && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);\nvar delegatedEvents = new Map();\nfunction handleEvent(name, lastEvent, nextEvent, dom) {\n    var delegatedRoots = delegatedEvents.get(name);\n    if (nextEvent) {\n        if (!delegatedRoots) {\n            delegatedRoots = { items: new Map(), count: 0, docEvent: null };\n            delegatedRoots.docEvent = attachEventToDocument(name, delegatedRoots);\n            delegatedEvents.set(name, delegatedRoots);\n        }\n        if (!lastEvent) {\n            delegatedRoots.count++;\n            if (isiOS && name === 'onClick') {\n                trapClickOnNonInteractiveElement(dom);\n            }\n        }\n        delegatedRoots.items.set(dom, nextEvent);\n    }\n    else if (delegatedRoots) {\n        if (delegatedRoots.items.has(dom)) {\n            delegatedRoots.count--;\n            delegatedRoots.items.delete(dom);\n            if (delegatedRoots.count === 0) {\n                document.removeEventListener(normalizeEventName(name), delegatedRoots.docEvent);\n                delegatedEvents.delete(name);\n            }\n        }\n    }\n}\nfunction dispatchEvent(event, dom, items, count, eventData) {\n    var eventsToTrigger = items.get(dom);\n    if (eventsToTrigger) {\n        count--;\n        // linkEvent object\n        eventData.dom = dom;\n        if (eventsToTrigger.event) {\n            eventsToTrigger.event(eventsToTrigger.data, event);\n        }\n        else {\n            eventsToTrigger(event);\n        }\n        if (eventData.stopPropagation) {\n            return;\n        }\n    }\n    if (count > 0) {\n        var parentDom = dom.parentNode;\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n        // because the event listener is on document.body\n        if (parentDom && parentDom.disabled !== true || parentDom === document.body) {\n            dispatchEvent(event, parentDom, items, count, eventData);\n        }\n    }\n}\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction attachEventToDocument(name, delegatedRoots) {\n    var docEvent = function (event) {\n        var eventData = {\n            stopPropagation: false,\n            dom: document\n        };\n        // we have to do this as some browsers recycle the same Event between calls\n        // so we need to make the property configurable\n        Object.defineProperty(event, 'currentTarget', {\n            configurable: true,\n            get: function get() {\n                return eventData.dom;\n            }\n        });\n        event.stopPropagation = function () {\n            eventData.stopPropagation = true;\n        };\n        var count = delegatedRoots.count;\n        if (count > 0) {\n            dispatchEvent(event, event.target, delegatedRoots.items, count, eventData);\n        }\n    };\n    document.addEventListener(normalizeEventName(name), docEvent);\n    return docEvent;\n}\nfunction emptyFn() { }\nfunction trapClickOnNonInteractiveElement(dom) {\n    // Mobile Safari does not fire properly bubble click events on\n    // non-interactive elements, which means delegated click listeners do not\n    // fire. The workaround for this bug involves attaching an empty click\n    // listener on the target node.\n    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n    // Just set it using the onclick property so that we don't have to manage any\n    // bookkeeping for it. Not sure if we need to clear it when the listener is\n    // removed.\n    // TODO: Only do this for the relevant Safaris maybe?\n    dom.onclick = emptyFn;\n}\n\nvar componentPools = new Map();\nvar elementPools = new Map();\nfunction recycleElement(vNode, lifecycle, context, isSVG) {\n    var tag = vNode.type;\n    var pools = elementPools.get(tag);\n    if (!isUndefined(pools)) {\n        var key = vNode.key;\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\n        if (!isUndefined(pool)) {\n            var recycledVNode = pool.pop();\n            if (!isUndefined(recycledVNode)) {\n                patchElement(recycledVNode, vNode, null, lifecycle, context, isSVG, true);\n                return vNode.dom;\n            }\n        }\n    }\n    return null;\n}\nfunction poolElement(vNode) {\n    var tag = vNode.type;\n    var key = vNode.key;\n    var pools = elementPools.get(tag);\n    if (isUndefined(pools)) {\n        pools = {\n            nonKeyed: [],\n            keyed: new Map()\n        };\n        elementPools.set(tag, pools);\n    }\n    if (isNull(key)) {\n        pools.nonKeyed.push(vNode);\n    }\n    else {\n        var pool = pools.keyed.get(key);\n        if (isUndefined(pool)) {\n            pool = [];\n            pools.keyed.set(key, pool);\n        }\n        pool.push(vNode);\n    }\n}\nfunction recycleComponent(vNode, lifecycle, context, isSVG) {\n    var type = vNode.type;\n    var pools = componentPools.get(type);\n    if (!isUndefined(pools)) {\n        var key = vNode.key;\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\n        if (!isUndefined(pool)) {\n            var recycledVNode = pool.pop();\n            if (!isUndefined(recycledVNode)) {\n                var flags = vNode.flags;\n                var failed = patchComponent(recycledVNode, vNode, null, lifecycle, context, isSVG, flags & 4 /* ComponentClass */, true);\n                if (!failed) {\n                    return vNode.dom;\n                }\n            }\n        }\n    }\n    return null;\n}\nfunction poolComponent(vNode) {\n    var hooks = vNode.ref;\n    var nonRecycleHooks = hooks && (hooks.onComponentWillMount ||\n        hooks.onComponentWillUnmount ||\n        hooks.onComponentDidMount ||\n        hooks.onComponentWillUpdate ||\n        hooks.onComponentDidUpdate);\n    if (nonRecycleHooks) {\n        return;\n    }\n    var type = vNode.type;\n    var key = vNode.key;\n    var pools = componentPools.get(type);\n    if (isUndefined(pools)) {\n        pools = {\n            nonKeyed: [],\n            keyed: new Map()\n        };\n        componentPools.set(type, pools);\n    }\n    if (isNull(key)) {\n        pools.nonKeyed.push(vNode);\n    }\n    else {\n        var pool = pools.keyed.get(key);\n        if (isUndefined(pool)) {\n            pool = [];\n            pools.keyed.set(key, pool);\n        }\n        pool.push(vNode);\n    }\n}\n\nfunction unmount(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var flags = vNode.flags;\n    if (flags & 28 /* Component */) {\n        unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling);\n    }\n    else if (flags & 3970 /* Element */) {\n        unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling);\n    }\n    else if (flags & (1 /* Text */ | 4096 /* Void */)) {\n        unmountVoidOrText(vNode, parentDom);\n    }\n}\nfunction unmountVoidOrText(vNode, parentDom) {\n    if (parentDom) {\n        removeChild(parentDom, vNode.dom);\n    }\n}\nfunction unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var instance = vNode.children;\n    var flags = vNode.flags;\n    var isStatefulComponent$$1 = flags & 4;\n    var ref = vNode.ref;\n    var dom = vNode.dom;\n    if (!isRecycling) {\n        if (isStatefulComponent$$1) {\n            if (!instance._unmounted) {\n                instance._ignoreSetState = true;\n                options.beforeUnmount && options.beforeUnmount(vNode);\n                instance.componentWillUnmount && instance.componentWillUnmount();\n                if (ref && !isRecycling) {\n                    ref(null);\n                }\n                instance._unmounted = true;\n                options.findDOMNodeEnabled && componentToDOMNodeMap.delete(instance);\n                var subLifecycle = instance._lifecycle;\n                unmount(instance._lastInput, null, subLifecycle, false, isRecycling);\n            }\n        }\n        else {\n            if (!isNullOrUndef(ref)) {\n                if (!isNullOrUndef(ref.onComponentWillUnmount)) {\n                    ref.onComponentWillUnmount(dom);\n                }\n            }\n            unmount(instance, null, lifecycle, false, isRecycling);\n        }\n    }\n    if (parentDom) {\n        var lastInput = instance._lastInput;\n        if (isNullOrUndef(lastInput)) {\n            lastInput = instance;\n        }\n        removeChild(parentDom, dom);\n    }\n    if (options.recyclingEnabled && !isStatefulComponent$$1 && (parentDom || canRecycle)) {\n        poolComponent(vNode);\n    }\n}\nfunction unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var dom = vNode.dom;\n    var ref = vNode.ref;\n    var events = vNode.events;\n    if (ref && !isRecycling) {\n        unmountRef(ref);\n    }\n    var children = vNode.children;\n    if (!isNullOrUndef(children)) {\n        unmountChildren$1(children, lifecycle, isRecycling);\n    }\n    if (!isNull(events)) {\n        for (var name in events) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchEvent(name, events[name], null, dom);\n            events[name] = null;\n        }\n    }\n    if (parentDom) {\n        removeChild(parentDom, dom);\n    }\n    if (options.recyclingEnabled && (parentDom || canRecycle)) {\n        poolElement(vNode);\n    }\n}\nfunction unmountChildren$1(children, lifecycle, isRecycling) {\n    if (isArray(children)) {\n        for (var i = 0, len = children.length; i < len; i++) {\n            var child = children[i];\n            if (!isInvalid(child) && isObject(child)) {\n                unmount(child, null, lifecycle, false, isRecycling);\n            }\n        }\n    }\n    else if (isObject(children)) {\n        unmount(children, null, lifecycle, false, isRecycling);\n    }\n}\nfunction unmountRef(ref) {\n    if (isFunction(ref)) {\n        ref(null);\n    }\n    else {\n        if (isInvalid(ref)) {\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n        }\n        throwError();\n    }\n}\n\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nvar EMPTY_OBJ = {};\nif (process.env.NODE_ENV !== 'production') {\n    Object.freeze(EMPTY_OBJ);\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG) {\n    if (isUndefined(context)) {\n        context = EMPTY_OBJ; // Context should not be mutable\n    }\n    var instance = new Component(props, context);\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    instance._patch = patch;\n    if (options.findDOMNodeEnabled) {\n        instance._componentToDOMNodeMap = componentToDOMNodeMap;\n    }\n    instance._unmounted = false;\n    instance._pendingSetState = true;\n    instance._isSVG = isSVG;\n    if (isFunction(instance.componentWillMount)) {\n        instance.componentWillMount();\n    }\n    var childContext = instance.getChildContext();\n    if (isNullOrUndef(childContext)) {\n        instance._childContext = context;\n    }\n    else {\n        instance._childContext = Object.assign({}, context, childContext);\n    }\n    options.beforeRender && options.beforeRender(instance);\n    var input = instance.render(props, instance.state, context);\n    options.afterRender && options.afterRender(instance);\n    if (isArray(input)) {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n        }\n        throwError();\n    }\n    else if (isInvalid(input)) {\n        input = createVoidVNode();\n    }\n    else if (isStringOrNumber(input)) {\n        input = createTextVNode(input);\n    }\n    else {\n        if (input.dom) {\n            input = cloneVNode(input);\n        }\n        if (input.flags & 28 /* Component */) {\n            // if we have an input that is also a component, we run into a tricky situation\n            // where the root vNode needs to always have the correct DOM entry\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\n            // we can optimise this in the future, but this gets us out of a lot of issues\n            input.parentVNode = vNode;\n        }\n    }\n    instance._pendingSetState = false;\n    instance._lastInput = input;\n    return instance;\n}\nfunction replaceLastChildAndUnmount(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling) {\n    replaceVNode(parentDom, mount(nextInput, null, lifecycle, context, isSVG), lastInput, lifecycle, isRecycling);\n}\nfunction replaceVNode(parentDom, dom, vNode, lifecycle, isRecycling) {\n    var shallowUnmount = false;\n    // we cannot cache nodeType here as vNode might be re-assigned below\n    if (vNode.flags & 28 /* Component */) {\n        // if we are accessing a stateful or stateless component, we want to access their last rendered input\n        // accessing their DOM node is not useful to us here\n        unmount(vNode, null, lifecycle, false, isRecycling);\n        vNode = vNode.children._lastInput || vNode.children;\n        shallowUnmount = true;\n    }\n    replaceChild(parentDom, dom, vNode.dom);\n    unmount(vNode, null, lifecycle, false, isRecycling);\n}\nfunction createFunctionalComponentInput(vNode, component, props, context) {\n    var input = component(props, context);\n    if (isArray(input)) {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n        }\n        throwError();\n    }\n    else if (isInvalid(input)) {\n        input = createVoidVNode();\n    }\n    else if (isStringOrNumber(input)) {\n        input = createTextVNode(input);\n    }\n    else {\n        if (input.dom) {\n            input = cloneVNode(input);\n        }\n        if (input.flags & 28 /* Component */) {\n            // if we have an input that is also a component, we run into a tricky situation\n            // where the root vNode needs to always have the correct DOM entry\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\n            // we can optimise this in the future, but this gets us out of a lot of issues\n            input.parentVNode = vNode;\n        }\n    }\n    return input;\n}\nfunction setTextContent(dom, text) {\n    if (text !== '') {\n        dom.textContent = text;\n    }\n    else {\n        dom.appendChild(document.createTextNode(''));\n    }\n}\nfunction updateTextContent(dom, text) {\n    dom.firstChild.nodeValue = text;\n}\nfunction appendChild(parentDom, dom) {\n    parentDom.appendChild(dom);\n}\nfunction insertOrAppend(parentDom, newNode, nextNode) {\n    if (isNullOrUndef(nextNode)) {\n        appendChild(parentDom, newNode);\n    }\n    else {\n        parentDom.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG === true) {\n        return document.createElementNS(svgNS, tag);\n    }\n    else {\n        return document.createElement(tag);\n    }\n}\nfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    unmount(lastNode, null, lifecycle, false, isRecycling);\n    var dom = mount(nextNode, null, lifecycle, context, isSVG);\n    nextNode.dom = dom;\n    replaceChild(parentDom, dom, lastNode.dom);\n}\nfunction replaceChild(parentDom, nextDom, lastDom) {\n    if (!parentDom) {\n        parentDom = lastDom.parentNode;\n    }\n    parentDom.replaceChild(nextDom, lastDom);\n}\nfunction removeChild(parentDom, dom) {\n    parentDom.removeChild(dom);\n}\nfunction removeAllChildren(dom, children, lifecycle, isRecycling) {\n    dom.textContent = '';\n    if (!options.recyclingEnabled || (options.recyclingEnabled && !isRecycling)) {\n        removeChildren(null, children, lifecycle, isRecycling);\n    }\n}\nfunction removeChildren(dom, children, lifecycle, isRecycling) {\n    for (var i = 0, len = children.length; i < len; i++) {\n        var child = children[i];\n        if (!isInvalid(child)) {\n            unmount(child, dom, lifecycle, true, isRecycling);\n        }\n    }\n}\nfunction isKeyed(lastChildren, nextChildren) {\n    return nextChildren.length && !isNullOrUndef(nextChildren[0]) && !isNullOrUndef(nextChildren[0].key)\n        && lastChildren.length && !isNullOrUndef(lastChildren[0]) && !isNullOrUndef(lastChildren[0].key);\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nfunction isControlled(props) {\n    var usesChecked = isCheckedType(props.type);\n    return usesChecked ? !isNullOrUndef(props.checked) : !isNullOrUndef(props.value);\n}\nfunction onTextInputChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onInput) {\n        var event = events.onInput;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.oninput) {\n        events.oninput(e);\n    }\n    // the user may have updated the vNode from the above onInput events\n    // so we need to get it from the context of `this` again\n    applyValue(this.vNode, dom);\n}\nfunction wrappedOnChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var event = events.onChange;\n    if (event.event) {\n        event.event(event.data, e);\n    }\n    else {\n        event(e);\n    }\n}\nfunction onCheckboxChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onClick) {\n        var event = events.onClick;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.onclick) {\n        events.onclick(e);\n    }\n    // the user may have updated the vNode from the above onClick events\n    // so we need to get it from the context of `this` again\n    applyValue(this.vNode, dom);\n}\nfunction handleAssociatedRadioInputs(name) {\n    var inputs = document.querySelectorAll((\"input[type=\\\"radio\\\"][name=\\\"\" + name + \"\\\"]\"));\n    [].forEach.call(inputs, function (dom) {\n        var inputWrapper = wrappers.get(dom);\n        if (inputWrapper) {\n            var props = inputWrapper.vNode.props;\n            if (props) {\n                dom.checked = inputWrapper.vNode.props.checked;\n            }\n        }\n    });\n}\nfunction processInput(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    applyValue(vNode, dom);\n    if (isControlled(props)) {\n        var inputWrapper = wrappers.get(dom);\n        if (!inputWrapper) {\n            inputWrapper = {\n                vNode: vNode\n            };\n            if (isCheckedType(props.type)) {\n                dom.onclick = onCheckboxChange.bind(inputWrapper);\n                dom.onclick.wrapped = true;\n            }\n            else {\n                dom.oninput = onTextInputChange.bind(inputWrapper);\n                dom.oninput.wrapped = true;\n            }\n            if (props.onChange) {\n                dom.onchange = wrappedOnChange.bind(inputWrapper);\n                dom.onchange.wrapped = true;\n            }\n            wrappers.set(dom, inputWrapper);\n        }\n        inputWrapper.vNode = vNode;\n        return true;\n    }\n    return false;\n}\nfunction applyValue(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    var type = props.type;\n    var value = props.value;\n    var checked = props.checked;\n    var multiple = props.multiple;\n    var defaultValue = props.defaultValue;\n    var hasValue = !isNullOrUndef(value);\n    if (type && type !== dom.type) {\n        dom.type = type;\n    }\n    if (multiple && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\n        dom.defaultValue = defaultValue + '';\n    }\n    if (isCheckedType(type)) {\n        if (hasValue) {\n            dom.value = value;\n        }\n        if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n        if (type === 'radio' && props.name) {\n            handleAssociatedRadioInputs(props.name);\n        }\n    }\n    else {\n        if (hasValue && dom.value !== value) {\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction isControlled$1(props) {\n    return !isNullOrUndef(props.value);\n}\nfunction updateChildOptionGroup(vNode, value) {\n    var type = vNode.type;\n    if (type === 'optgroup') {\n        var children = vNode.children;\n        if (isArray(children)) {\n            for (var i = 0, len = children.length; i < len; i++) {\n                updateChildOption(children[i], value);\n            }\n        }\n        else if (isVNode(children)) {\n            updateChildOption(children, value);\n        }\n    }\n    else {\n        updateChildOption(vNode, value);\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if ((isArray(value) && value.indexOf(props.value) !== -1) || props.value === value) {\n        dom.selected = true;\n    }\n    else {\n        dom.selected = props.selected || false;\n    }\n}\nfunction onSelectChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onChange) {\n        var event = events.onChange;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.onchange) {\n        events.onchange(e);\n    }\n    // the user may have updated the vNode from the above onChange events\n    // so we need to get it from the context of `this` again\n    applyValue$1(this.vNode, dom);\n}\nfunction processSelect(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    applyValue$1(vNode, dom);\n    if (isControlled$1(props)) {\n        var selectWrapper = wrappers.get(dom);\n        if (!selectWrapper) {\n            selectWrapper = {\n                vNode: vNode\n            };\n            dom.onchange = onSelectChange.bind(selectWrapper);\n            dom.onchange.wrapped = true;\n            wrappers.set(dom, selectWrapper);\n        }\n        selectWrapper.vNode = vNode;\n        return true;\n    }\n    return false;\n}\nfunction applyValue$1(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    if (props.multiple !== dom.multiple) {\n        dom.multiple = props.multiple;\n    }\n    var children = vNode.children;\n    if (!isInvalid(children)) {\n        var value = props.value;\n        if (isArray(children)) {\n            for (var i = 0, len = children.length; i < len; i++) {\n                updateChildOptionGroup(children[i], value);\n            }\n        }\n        else if (isVNode(children)) {\n            updateChildOptionGroup(children, value);\n        }\n    }\n}\n\nfunction isControlled$2(props) {\n    return !isNullOrUndef(props.value);\n}\nfunction wrappedOnChange$1(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var event = events.onChange;\n    if (event.event) {\n        event.event(event.data, e);\n    }\n    else {\n        event(e);\n    }\n}\nfunction onTextareaInputChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onInput) {\n        var event = events.onInput;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.oninput) {\n        events.oninput(e);\n    }\n    // the user may have updated the vNode from the above onInput events\n    // so we need to get it from the context of `this` again\n    applyValue$2(this.vNode, dom, false);\n}\nfunction processTextarea(vNode, dom, mounting) {\n    var props = vNode.props || EMPTY_OBJ;\n    applyValue$2(vNode, dom, mounting);\n    var textareaWrapper = wrappers.get(dom);\n    if (isControlled$2(props)) {\n        if (!textareaWrapper) {\n            textareaWrapper = {\n                vNode: vNode\n            };\n            dom.oninput = onTextareaInputChange.bind(textareaWrapper);\n            dom.oninput.wrapped = true;\n            if (props.onChange) {\n                dom.onchange = wrappedOnChange$1.bind(textareaWrapper);\n                dom.onchange.wrapped = true;\n            }\n            wrappers.set(dom, textareaWrapper);\n        }\n        textareaWrapper.vNode = vNode;\n        return true;\n    }\n    return false;\n}\nfunction applyValue$2(vNode, dom, mounting) {\n    var props = vNode.props || EMPTY_OBJ;\n    var value = props.value;\n    var domValue = dom.value;\n    if (isNullOrUndef(value)) {\n        if (mounting) {\n            var defaultValue = props.defaultValue;\n            if (!isNullOrUndef(defaultValue)) {\n                if (defaultValue !== domValue) {\n                    dom.value = defaultValue;\n                }\n            }\n            else if (domValue !== '') {\n                dom.value = '';\n            }\n        }\n    }\n    else {\n        /* There is value so keep it controlled */\n        if (domValue !== value) {\n            dom.value = value;\n        }\n    }\n}\n\nvar wrappers = new Map();\nfunction processElement(flags, vNode, dom, mounting) {\n    if (flags & 512 /* InputElement */) {\n        return processInput(vNode, dom);\n    }\n    if (flags & 2048 /* SelectElement */) {\n        return processSelect(vNode, dom);\n    }\n    if (flags & 1024 /* TextareaElement */) {\n        return processTextarea(vNode, dom, mounting);\n    }\n    return false;\n}\n\nfunction patch(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    if (lastVNode !== nextVNode) {\n        var lastFlags = lastVNode.flags;\n        var nextFlags = nextVNode.flags;\n        if (nextFlags & 28 /* Component */) {\n            if (lastFlags & 28 /* Component */) {\n                patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, nextFlags & 4 /* ComponentClass */, isRecycling);\n            }\n            else {\n                replaceVNode(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, nextFlags & 4 /* ComponentClass */), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 3970 /* Element */) {\n            if (lastFlags & 3970 /* Element */) {\n                patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n            }\n            else {\n                replaceVNode(parentDom, mountElement(nextVNode, null, lifecycle, context, isSVG), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 1 /* Text */) {\n            if (lastFlags & 1 /* Text */) {\n                patchText(lastVNode, nextVNode);\n            }\n            else {\n                replaceVNode(parentDom, mountText(nextVNode, null), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 4096 /* Void */) {\n            if (lastFlags & 4096 /* Void */) {\n                patchVoid(lastVNode, nextVNode);\n            }\n            else {\n                replaceVNode(parentDom, mountVoid(nextVNode, null), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else {\n            // Error case: mount new one replacing old one\n            replaceLastChildAndUnmount(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n        }\n    }\n}\nfunction unmountChildren(children, dom, lifecycle, isRecycling) {\n    if (isVNode(children)) {\n        unmount(children, dom, lifecycle, true, isRecycling);\n    }\n    else if (isArray(children)) {\n        removeAllChildren(dom, children, lifecycle, isRecycling);\n    }\n    else {\n        dom.textContent = '';\n    }\n}\nfunction patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    var nextTag = nextVNode.type;\n    var lastTag = lastVNode.type;\n    if (lastTag !== nextTag) {\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n    }\n    else {\n        var dom = lastVNode.dom;\n        var lastProps = lastVNode.props;\n        var nextProps = nextVNode.props;\n        var lastChildren = lastVNode.children;\n        var nextChildren = nextVNode.children;\n        var lastFlags = lastVNode.flags;\n        var nextFlags = nextVNode.flags;\n        var nextRef = nextVNode.ref;\n        var lastEvents = lastVNode.events;\n        var nextEvents = nextVNode.events;\n        nextVNode.dom = dom;\n        if (isSVG || (nextFlags & 128 /* SvgElement */)) {\n            isSVG = true;\n        }\n        if (lastChildren !== nextChildren) {\n            patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        var hasControlledValue = false;\n        if (!(nextFlags & 2 /* HtmlElement */)) {\n            hasControlledValue = processElement(nextFlags, nextVNode, dom, false);\n        }\n        // inlined patchProps  -- starts --\n        if (lastProps !== nextProps) {\n            var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n            var nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n            if (nextPropsOrEmpty !== EMPTY_OBJ) {\n                for (var prop in nextPropsOrEmpty) {\n                    // do not add a hasOwnProperty check here, it affects performance\n                    var nextValue = nextPropsOrEmpty[prop];\n                    var lastValue = lastPropsOrEmpty[prop];\n                    if (isNullOrUndef(nextValue)) {\n                        removeProp(prop, nextValue, dom);\n                    }\n                    else {\n                        patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue);\n                    }\n                }\n            }\n            if (lastPropsOrEmpty !== EMPTY_OBJ) {\n                for (var prop$1 in lastPropsOrEmpty) {\n                    // do not add a hasOwnProperty check here, it affects performance\n                    if (isNullOrUndef(nextPropsOrEmpty[prop$1])) {\n                        removeProp(prop$1, lastPropsOrEmpty[prop$1], dom);\n                    }\n                }\n            }\n        }\n        // inlined patchProps  -- ends --\n        if (lastEvents !== nextEvents) {\n            patchEvents(lastEvents, nextEvents, dom);\n        }\n        if (nextRef) {\n            if (lastVNode.ref !== nextRef || isRecycling) {\n                mountRef(dom, nextRef, lifecycle);\n            }\n        }\n    }\n}\nfunction patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\n    var patchArray = false;\n    var patchKeyed = false;\n    if (nextFlags & 64 /* HasNonKeyedChildren */) {\n        patchArray = true;\n    }\n    else if ((lastFlags & 32 /* HasKeyedChildren */) && (nextFlags & 32 /* HasKeyedChildren */)) {\n        patchKeyed = true;\n        patchArray = true;\n    }\n    else if (isInvalid(nextChildren)) {\n        unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n    }\n    else if (isInvalid(lastChildren)) {\n        if (isStringOrNumber(nextChildren)) {\n            setTextContent(dom, nextChildren);\n        }\n        else {\n            if (isArray(nextChildren)) {\n                mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\n            }\n            else {\n                mount(nextChildren, dom, lifecycle, context, isSVG);\n            }\n        }\n    }\n    else if (isStringOrNumber(nextChildren)) {\n        if (isStringOrNumber(lastChildren)) {\n            updateTextContent(dom, nextChildren);\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            setTextContent(dom, nextChildren);\n        }\n    }\n    else if (isArray(nextChildren)) {\n        if (isArray(lastChildren)) {\n            patchArray = true;\n            if (isKeyed(lastChildren, nextChildren)) {\n                patchKeyed = true;\n            }\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\n        }\n    }\n    else if (isArray(lastChildren)) {\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\n        mount(nextChildren, dom, lifecycle, context, isSVG);\n    }\n    else if (isVNode(nextChildren)) {\n        if (isVNode(lastChildren)) {\n            patch(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            mount(nextChildren, dom, lifecycle, context, isSVG);\n        }\n    }\n    if (patchArray) {\n        if (patchKeyed) {\n            patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        else {\n            patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n    }\n}\nfunction patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling) {\n    var lastType = lastVNode.type;\n    var nextType = nextVNode.type;\n    var lastKey = lastVNode.key;\n    var nextKey = nextVNode.key;\n    if (lastType !== nextType || lastKey !== nextKey) {\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n        return false;\n    }\n    else {\n        var nextProps = nextVNode.props || EMPTY_OBJ;\n        if (isClass) {\n            var instance = lastVNode.children;\n            if (instance._unmounted) {\n                if (isNull(parentDom)) {\n                    return true;\n                }\n                replaceChild(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, nextVNode.flags & 4 /* ComponentClass */), lastVNode.dom);\n            }\n            else {\n                var lastState = instance.state;\n                var nextState = instance.state;\n                var lastProps = instance.props;\n                var childContext = instance.getChildContext();\n                nextVNode.children = instance;\n                instance._isSVG = isSVG;\n                instance._syncSetState = false;\n                if (isNullOrUndef(childContext)) {\n                    childContext = context;\n                }\n                else {\n                    childContext = Object.assign({}, context, childContext);\n                }\n                var lastInput = instance._lastInput;\n                var nextInput = instance._updateComponent(lastState, nextState, lastProps, nextProps, context, false, false);\n                var didUpdate = true;\n                instance._childContext = childContext;\n                if (isInvalid(nextInput)) {\n                    nextInput = createVoidVNode();\n                }\n                else if (nextInput === NO_OP) {\n                    nextInput = lastInput;\n                    didUpdate = false;\n                }\n                else if (isStringOrNumber(nextInput)) {\n                    nextInput = createTextVNode(nextInput);\n                }\n                else if (isArray(nextInput)) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n                    }\n                    throwError();\n                }\n                else if (isObject(nextInput) && nextInput.dom) {\n                    nextInput = cloneVNode(nextInput);\n                }\n                if (nextInput.flags & 28 /* Component */) {\n                    nextInput.parentVNode = nextVNode;\n                }\n                else if (lastInput.flags & 28 /* Component */) {\n                    lastInput.parentVNode = nextVNode;\n                }\n                instance._lastInput = nextInput;\n                instance._vNode = nextVNode;\n                if (didUpdate) {\n                    patch(lastInput, nextInput, parentDom, lifecycle, childContext, isSVG, isRecycling);\n                    instance.componentDidUpdate(lastProps, lastState);\n                    options.afterUpdate && options.afterUpdate(nextVNode);\n                    options.findDOMNodeEnabled && componentToDOMNodeMap.set(instance, nextInput.dom);\n                }\n                instance._syncSetState = true;\n                nextVNode.dom = nextInput.dom;\n            }\n        }\n        else {\n            var shouldUpdate = true;\n            var lastProps$1 = lastVNode.props;\n            var nextHooks = nextVNode.ref;\n            var nextHooksDefined = !isNullOrUndef(nextHooks);\n            var lastInput$1 = lastVNode.children;\n            var nextInput$1 = lastInput$1;\n            nextVNode.dom = lastVNode.dom;\n            nextVNode.children = lastInput$1;\n            if (lastKey !== nextKey) {\n                shouldUpdate = true;\n            }\n            else {\n                if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentShouldUpdate)) {\n                    shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps$1, nextProps);\n                }\n            }\n            if (shouldUpdate !== false) {\n                if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentWillUpdate)) {\n                    nextHooks.onComponentWillUpdate(lastProps$1, nextProps);\n                }\n                nextInput$1 = nextType(nextProps, context);\n                if (isInvalid(nextInput$1)) {\n                    nextInput$1 = createVoidVNode();\n                }\n                else if (isStringOrNumber(nextInput$1) && nextInput$1 !== NO_OP) {\n                    nextInput$1 = createTextVNode(nextInput$1);\n                }\n                else if (isArray(nextInput$1)) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n                    }\n                    throwError();\n                }\n                else if (isObject(nextInput$1) && nextInput$1.dom) {\n                    nextInput$1 = cloneVNode(nextInput$1);\n                }\n                if (nextInput$1 !== NO_OP) {\n                    patch(lastInput$1, nextInput$1, parentDom, lifecycle, context, isSVG, isRecycling);\n                    nextVNode.children = nextInput$1;\n                    if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentDidUpdate)) {\n                        nextHooks.onComponentDidUpdate(lastProps$1, nextProps);\n                    }\n                    nextVNode.dom = nextInput$1.dom;\n                }\n            }\n            if (nextInput$1.flags & 28 /* Component */) {\n                nextInput$1.parentVNode = nextVNode;\n            }\n            else if (lastInput$1.flags & 28 /* Component */) {\n                lastInput$1.parentVNode = nextVNode;\n            }\n        }\n    }\n    return false;\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = lastVNode.dom;\n    nextVNode.dom = dom;\n    if (lastVNode.children !== nextText) {\n        dom.nodeValue = nextText;\n    }\n}\nfunction patchVoid(lastVNode, nextVNode) {\n    nextVNode.dom = lastVNode.dom;\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\n    var lastChildrenLength = lastChildren.length;\n    var nextChildrenLength = nextChildren.length;\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    for (; i < commonLength; i++) {\n        var nextChild = nextChildren[i];\n        if (nextChild.dom) {\n            nextChild = nextChildren[i] = cloneVNode(nextChild);\n        }\n        patch(lastChildren[i], nextChild, dom, lifecycle, context, isSVG, isRecycling);\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; i++) {\n            var nextChild$1 = nextChildren[i];\n            if (nextChild$1.dom) {\n                nextChild$1 = nextChildren[i] = cloneVNode(nextChild$1);\n            }\n            appendChild(dom, mount(nextChild$1, null, lifecycle, context, isSVG));\n        }\n    }\n    else if (nextChildrenLength === 0) {\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; i++) {\n            unmount(lastChildren[i], dom, lifecycle, false, isRecycling);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, lifecycle, context, isSVG, isRecycling) {\n    var aLength = a.length;\n    var bLength = b.length;\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var aStart = 0;\n    var bStart = 0;\n    var i;\n    var j;\n    var aNode;\n    var bNode;\n    var nextNode;\n    var nextPos;\n    var node;\n    if (aLength === 0) {\n        if (bLength !== 0) {\n            mountArrayChildren(b, dom, lifecycle, context, isSVG);\n        }\n        return;\n    }\n    else if (bLength === 0) {\n        removeAllChildren(dom, a, lifecycle, isRecycling);\n        return;\n    }\n    var aStartNode = a[aStart];\n    var bStartNode = b[bStart];\n    var aEndNode = a[aEnd];\n    var bEndNode = b[bEnd];\n    if (bStartNode.dom) {\n        b[bStart] = bStartNode = cloneVNode(bStartNode);\n    }\n    if (bEndNode.dom) {\n        b[bEnd] = bEndNode = cloneVNode(bEndNode);\n    }\n    // Step 1\n    /* eslint no-constant-condition: 0 */\n    outer: while (true) {\n        // Sync nodes with the same key at the beginning.\n        while (aStartNode.key === bStartNode.key) {\n            patch(aStartNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\n            aStart++;\n            bStart++;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aStartNode = a[aStart];\n            bStartNode = b[bStart];\n            if (bStartNode.dom) {\n                b[bStart] = bStartNode = cloneVNode(bStartNode);\n            }\n        }\n        // Sync nodes with the same key at the end.\n        while (aEndNode.key === bEndNode.key) {\n            patch(aEndNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\n            aEnd--;\n            bEnd--;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aEndNode = a[aEnd];\n            bEndNode = b[bEnd];\n            if (bEndNode.dom) {\n                b[bEnd] = bEndNode = cloneVNode(bEndNode);\n            }\n        }\n        // Move and sync nodes from right to left.\n        if (aEndNode.key === bStartNode.key) {\n            patch(aEndNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\n            insertOrAppend(dom, bStartNode.dom, aStartNode.dom);\n            aEnd--;\n            bStart++;\n            aEndNode = a[aEnd];\n            bStartNode = b[bStart];\n            if (bStartNode.dom) {\n                b[bStart] = bStartNode = cloneVNode(bStartNode);\n            }\n            continue;\n        }\n        // Move and sync nodes from left to right.\n        if (aStartNode.key === bEndNode.key) {\n            patch(aStartNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\n            nextPos = bEnd + 1;\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n            insertOrAppend(dom, bEndNode.dom, nextNode);\n            aStart++;\n            bEnd--;\n            aStartNode = a[aStart];\n            bEndNode = b[bEnd];\n            if (bEndNode.dom) {\n                b[bEnd] = bEndNode = cloneVNode(bEndNode);\n            }\n            continue;\n        }\n        break;\n    }\n    if (aStart > aEnd) {\n        if (bStart <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n            while (bStart <= bEnd) {\n                node = b[bStart];\n                if (node.dom) {\n                    b[bStart] = node = cloneVNode(node);\n                }\n                bStart++;\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\n            }\n        }\n    }\n    else if (bStart > bEnd) {\n        while (aStart <= aEnd) {\n            unmount(a[aStart++], dom, lifecycle, false, isRecycling);\n        }\n    }\n    else {\n        aLength = aEnd - aStart + 1;\n        bLength = bEnd - bStart + 1;\n        var sources = new Array(bLength);\n        // Mark all nodes as inserted.\n        for (i = 0; i < bLength; i++) {\n            sources[i] = -1;\n        }\n        var moved = false;\n        var pos = 0;\n        var patched = 0;\n        // When sizes are small, just loop them through\n        if ((bLength <= 4) || (aLength * bLength <= 16)) {\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLength) {\n                    for (j = bStart; j <= bEnd; j++) {\n                        bNode = b[j];\n                        if (aNode.key === bNode.key) {\n                            sources[j - bStart] = i;\n                            if (pos > j) {\n                                moved = true;\n                            }\n                            else {\n                                pos = j;\n                            }\n                            if (bNode.dom) {\n                                b[j] = bNode = cloneVNode(bNode);\n                            }\n                            patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\n                            patched++;\n                            a[i] = null;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            var keyIndex = new Map();\n            // Map keys by their index in array\n            for (i = bStart; i <= bEnd; i++) {\n                node = b[i];\n                keyIndex.set(node.key, i);\n            }\n            // Try to patch same keys\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLength) {\n                    j = keyIndex.get(aNode.key);\n                    if (!isUndefined(j)) {\n                        bNode = b[j];\n                        sources[j - bStart] = i;\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.dom) {\n                            b[j] = bNode = cloneVNode(bNode);\n                        }\n                        patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\n                        patched++;\n                        a[i] = null;\n                    }\n                }\n            }\n        }\n        // fast-path: if nothing patched remove all old and add all new\n        if (aLength === a.length && patched === 0) {\n            removeAllChildren(dom, a, lifecycle, isRecycling);\n            while (bStart < bLength) {\n                node = b[bStart];\n                if (node.dom) {\n                    b[bStart] = node = cloneVNode(node);\n                }\n                bStart++;\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), null);\n            }\n        }\n        else {\n            i = aLength - patched;\n            while (i > 0) {\n                aNode = a[aStart++];\n                if (!isNull(aNode)) {\n                    unmount(aNode, dom, lifecycle, true, isRecycling);\n                    i--;\n                }\n            }\n            if (moved) {\n                var seq = lis_algorithm(sources);\n                j = seq.length - 1;\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        if (node.dom) {\n                            b[pos] = node = cloneVNode(node);\n                        }\n                        nextPos = pos + 1;\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                        insertOrAppend(dom, mount(node, dom, lifecycle, context, isSVG), nextNode);\n                    }\n                    else {\n                        if (j < 0 || i !== seq[j]) {\n                            pos = i + bStart;\n                            node = b[pos];\n                            nextPos = pos + 1;\n                            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                            insertOrAppend(dom, node.dom, nextNode);\n                        }\n                        else {\n                            j--;\n                        }\n                    }\n                }\n            }\n            else if (patched !== bLength) {\n                // when patched count doesn't match b length we need to insert those new ones\n                // loop backwards so we can use insertBefore\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        if (node.dom) {\n                            b[pos] = node = cloneVNode(node);\n                        }\n                        nextPos = pos + 1;\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\n                    }\n                }\n            }\n        }\n    }\n}\n// // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n    var p = arr.slice(0);\n    var result = [0];\n    var i;\n    var j;\n    var u;\n    var v;\n    var c;\n    var len = arr.length;\n    for (i = 0; i < len; i++) {\n        var arrI = arr[i];\n        if (arrI === -1) {\n            continue;\n        }\n        j = result[result.length - 1];\n        if (arr[j] < arrI) {\n            p[i] = j;\n            result.push(i);\n            continue;\n        }\n        u = 0;\n        v = result.length - 1;\n        while (u < v) {\n            c = ((u + v) / 2) | 0;\n            if (arr[result[c]] < arrI) {\n                u = c + 1;\n            }\n            else {\n                v = c;\n            }\n        }\n        if (arrI < arr[result[u]]) {\n            if (u > 0) {\n                p[i] = result[u - 1];\n            }\n            result[u] = i;\n        }\n    }\n    u = result.length;\n    v = result[u - 1];\n    while (u-- > 0) {\n        result[u] = v;\n        v = p[v];\n    }\n    return result;\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue) {\n    if (skipProps[prop] || hasControlledValue && prop === 'value') {\n        return;\n    }\n    if (booleanProps[prop]) {\n        dom[prop] = !!nextValue;\n    }\n    else if (strictProps[prop]) {\n        var value = isNullOrUndef(nextValue) ? '' : nextValue;\n        if (dom[prop] !== value) {\n            dom[prop] = value;\n        }\n    }\n    else if (lastValue !== nextValue) {\n        if (isAttrAnEvent(prop)) {\n            patchEvent(prop, lastValue, nextValue, dom);\n        }\n        else if (isNullOrUndef(nextValue)) {\n            dom.removeAttribute(prop);\n        }\n        else if (prop === 'className') {\n            if (isSVG) {\n                dom.setAttribute('class', nextValue);\n            }\n            else {\n                dom.className = nextValue;\n            }\n        }\n        else if (prop === 'style') {\n            patchStyle(lastValue, nextValue, dom);\n        }\n        else if (prop === 'dangerouslySetInnerHTML') {\n            var lastHtml = lastValue && lastValue.__html;\n            var nextHtml = nextValue && nextValue.__html;\n            if (lastHtml !== nextHtml) {\n                if (!isNullOrUndef(nextHtml)) {\n                    dom.innerHTML = nextHtml;\n                }\n            }\n        }\n        else {\n            var ns = namespaces[prop];\n            if (ns) {\n                dom.setAttributeNS(ns, prop, nextValue);\n            }\n            else {\n                dom.setAttribute(prop, nextValue);\n            }\n        }\n    }\n}\nfunction patchEvents(lastEvents, nextEvents, dom) {\n    lastEvents = lastEvents || EMPTY_OBJ;\n    nextEvents = nextEvents || EMPTY_OBJ;\n    if (nextEvents !== EMPTY_OBJ) {\n        for (var name in nextEvents) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchEvent(name, lastEvents[name], nextEvents[name], dom);\n        }\n    }\n    if (lastEvents !== EMPTY_OBJ) {\n        for (var name$1 in lastEvents) {\n            // do not add a hasOwnProperty check here, it affects performance\n            if (isNullOrUndef(nextEvents[name$1])) {\n                patchEvent(name$1, lastEvents[name$1], null, dom);\n            }\n        }\n    }\n}\nfunction patchEvent(name, lastValue, nextValue, dom) {\n    if (lastValue !== nextValue) {\n        var nameLowerCase = name.toLowerCase();\n        var domEvent = dom[nameLowerCase];\n        // if the function is wrapped, that means it's been controlled by a wrapper\n        if (domEvent && domEvent.wrapped) {\n            return;\n        }\n        if (delegatedProps[name]) {\n            handleEvent(name, lastValue, nextValue, dom);\n        }\n        else {\n            if (lastValue !== nextValue) {\n                if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {\n                    var linkEvent = nextValue.event;\n                    if (linkEvent && isFunction(linkEvent)) {\n                        if (!dom._data) {\n                            dom[nameLowerCase] = function (e) {\n                                linkEvent(e.currentTarget._data, e);\n                            };\n                        }\n                        dom._data = nextValue.data;\n                    }\n                    else {\n                        if (process.env.NODE_ENV !== 'production') {\n                            throwError((\"an event on a VNode \\\"\" + name + \"\\\". was not a function or a valid linkEvent.\"));\n                        }\n                        throwError();\n                    }\n                }\n                else {\n                    dom[nameLowerCase] = nextValue;\n                }\n            }\n        }\n    }\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    var domStyle = dom.style;\n    if (isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    for (var style in nextAttrValue) {\n        // do not add a hasOwnProperty check here, it affects performance\n        var value = nextAttrValue[style];\n        if (isNumber(value) && !isUnitlessNumber[style]) {\n            domStyle[style] = value + 'px';\n        }\n        else {\n            domStyle[style] = value;\n        }\n    }\n    if (!isNullOrUndef(lastAttrValue)) {\n        for (var style$1 in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style$1])) {\n                domStyle[style$1] = '';\n            }\n        }\n    }\n}\nfunction removeProp(prop, lastValue, dom) {\n    if (prop === 'className') {\n        dom.removeAttribute('class');\n    }\n    else if (prop === 'value') {\n        dom.value = '';\n    }\n    else if (prop === 'style') {\n        dom.removeAttribute('style');\n    }\n    else if (isAttrAnEvent(prop)) {\n        handleEvent(name, lastValue, null, dom);\n    }\n    else {\n        dom.removeAttribute(prop);\n    }\n}\n\nfunction mount(vNode, parentDom, lifecycle, context, isSVG) {\n    var flags = vNode.flags;\n    if (flags & 3970 /* Element */) {\n        return mountElement(vNode, parentDom, lifecycle, context, isSVG);\n    }\n    else if (flags & 28 /* Component */) {\n        return mountComponent(vNode, parentDom, lifecycle, context, isSVG, flags & 4 /* ComponentClass */);\n    }\n    else if (flags & 4096 /* Void */) {\n        return mountVoid(vNode, parentDom);\n    }\n    else if (flags & 1 /* Text */) {\n        return mountText(vNode, parentDom);\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof vNode === 'object') {\n                throwError((\"mount() received an object that's not a valid VNode, you should stringify it first. Object: \\\"\" + (JSON.stringify(vNode)) + \"\\\".\"));\n            }\n            else {\n                throwError((\"mount() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\n            }\n        }\n        throwError();\n    }\n}\nfunction mountText(vNode, parentDom) {\n    var dom = document.createTextNode(vNode.children);\n    vNode.dom = dom;\n    if (parentDom) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nfunction mountVoid(vNode, parentDom) {\n    var dom = document.createTextNode('');\n    vNode.dom = dom;\n    if (parentDom) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nfunction mountElement(vNode, parentDom, lifecycle, context, isSVG) {\n    if (options.recyclingEnabled) {\n        var dom$1 = recycleElement(vNode, lifecycle, context, isSVG);\n        if (!isNull(dom$1)) {\n            if (!isNull(parentDom)) {\n                appendChild(parentDom, dom$1);\n            }\n            return dom$1;\n        }\n    }\n    var flags = vNode.flags;\n    if (isSVG || (flags & 128 /* SvgElement */)) {\n        isSVG = true;\n    }\n    var dom = documentCreateElement(vNode.type, isSVG);\n    var children = vNode.children;\n    var props = vNode.props;\n    var events = vNode.events;\n    var ref = vNode.ref;\n    vNode.dom = dom;\n    if (!isInvalid(children)) {\n        if (isStringOrNumber(children)) {\n            setTextContent(dom, children);\n        }\n        else if (isArray(children)) {\n            mountArrayChildren(children, dom, lifecycle, context, isSVG);\n        }\n        else if (isVNode(children)) {\n            mount(children, dom, lifecycle, context, isSVG);\n        }\n    }\n    var hasControlledValue = false;\n    if (!(flags & 2 /* HtmlElement */)) {\n        hasControlledValue = processElement(flags, vNode, dom, true);\n    }\n    if (!isNull(props)) {\n        for (var prop in props) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\n        }\n    }\n    if (!isNull(events)) {\n        for (var name in events) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchEvent(name, null, events[name], dom);\n        }\n    }\n    if (!isNull(ref)) {\n        mountRef(dom, ref, lifecycle);\n    }\n    if (!isNull(parentDom)) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nfunction mountArrayChildren(children, dom, lifecycle, context, isSVG) {\n    for (var i = 0, len = children.length; i < len; i++) {\n        var child = children[i];\n        // TODO: Verify can string/number be here. might cause de-opt\n        if (!isInvalid(child)) {\n            if (child.dom) {\n                children[i] = child = cloneVNode(child);\n            }\n            mount(children[i], dom, lifecycle, context, isSVG);\n        }\n    }\n}\nfunction mountComponent(vNode, parentDom, lifecycle, context, isSVG, isClass) {\n    if (options.recyclingEnabled) {\n        var dom$1 = recycleComponent(vNode, lifecycle, context, isSVG);\n        if (!isNull(dom$1)) {\n            if (!isNull(parentDom)) {\n                appendChild(parentDom, dom$1);\n            }\n            return dom$1;\n        }\n    }\n    var type = vNode.type;\n    var props = vNode.props || EMPTY_OBJ;\n    var ref = vNode.ref;\n    var dom;\n    if (isClass) {\n        var instance = createClassComponentInstance(vNode, type, props, context, isSVG);\n        var input = instance._lastInput;\n        instance._vNode = vNode;\n        vNode.dom = dom = mount(input, null, lifecycle, instance._childContext, isSVG);\n        if (!isNull(parentDom)) {\n            appendChild(parentDom, dom);\n        }\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\n        options.findDOMNodeEnabled && componentToDOMNodeMap.set(instance, dom);\n        vNode.children = instance;\n    }\n    else {\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\n        vNode.dom = dom = mount(input$1, null, lifecycle, context, isSVG);\n        vNode.children = input$1;\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\n        if (!isNull(parentDom)) {\n            appendChild(parentDom, dom);\n        }\n    }\n    return dom;\n}\nfunction mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {\n    if (ref) {\n        if (isFunction(ref)) {\n            ref(instance);\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                if (isStringOrNumber(ref)) {\n                    throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n                }\n                else if (isObject(ref) && (vNode.flags & 4 /* ComponentClass */)) {\n                    throwError('functional component lifecycle events are not supported on ES2015 class components.');\n                }\n                else {\n                    throwError((\"a bad value for \\\"ref\\\" was used on component: \\\"\" + (JSON.stringify(ref)) + \"\\\"\"));\n                }\n            }\n            throwError();\n        }\n    }\n    var cDM = instance.componentDidMount;\n    var afterMount = options.afterMount;\n    if (!isUndefined(cDM) || !isNull(afterMount)) {\n        lifecycle.addListener(function () {\n            afterMount && afterMount(vNode);\n            cDM && instance.componentDidMount();\n            instance._syncSetState = true;\n        });\n    }\n    else {\n        instance._syncSetState = true;\n    }\n}\nfunction mountFunctionalComponentCallbacks(ref, dom, lifecycle) {\n    if (ref) {\n        if (!isNullOrUndef(ref.onComponentWillMount)) {\n            ref.onComponentWillMount();\n        }\n        if (!isNullOrUndef(ref.onComponentDidMount)) {\n            lifecycle.addListener(function () { return ref.onComponentDidMount(dom); });\n        }\n    }\n}\nfunction mountRef(dom, value, lifecycle) {\n    if (isFunction(value)) {\n        lifecycle.addListener(function () { return value(dom); });\n    }\n    else {\n        if (isInvalid(value)) {\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n        }\n        throwError();\n    }\n}\n\nfunction normalizeChildNodes(parentDom) {\n    var dom = parentDom.firstChild;\n    while (dom) {\n        if (dom.nodeType === 8) {\n            if (dom.data === '!') {\n                var placeholder = document.createTextNode('');\n                parentDom.replaceChild(placeholder, dom);\n                dom = dom.nextSibling;\n            }\n            else {\n                var lastDom = dom.previousSibling;\n                parentDom.removeChild(dom);\n                dom = lastDom || parentDom.firstChild;\n            }\n        }\n        else {\n            dom = dom.nextSibling;\n        }\n    }\n}\nfunction hydrateComponent(vNode, dom, lifecycle, context, isSVG, isClass) {\n    var type = vNode.type;\n    var ref = vNode.ref;\n    vNode.dom = dom;\n    var props = vNode.props || EMPTY_OBJ;\n    if (isClass) {\n        var _isSVG = dom.namespaceURI === svgNS;\n        var instance = createClassComponentInstance(vNode, type, props, context, _isSVG);\n        var input = instance._lastInput;\n        instance._vComponent = vNode;\n        instance._vNode = vNode;\n        hydrate(input, dom, lifecycle, instance._childContext, _isSVG);\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\n        options.findDOMNodeEnabled && componentToDOMNodeMap.set(instance, dom);\n        vNode.children = instance;\n    }\n    else {\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\n        hydrate(input$1, dom, lifecycle, context, isSVG);\n        vNode.children = input$1;\n        vNode.dom = input$1.dom;\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\n    }\n    return dom;\n}\nfunction hydrateElement(vNode, dom, lifecycle, context, isSVG) {\n    var children = vNode.children;\n    var props = vNode.props;\n    var events = vNode.events;\n    var flags = vNode.flags;\n    var ref = vNode.ref;\n    if (isSVG || (flags & 128 /* SvgElement */)) {\n        isSVG = true;\n    }\n    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {\n        if (process.env.NODE_ENV !== 'production') {\n            warning('Inferno hydration: Server-side markup doesn\\'t match client-side markup or Initial render target is not empty');\n        }\n        var newDom = mountElement(vNode, null, lifecycle, context, isSVG);\n        vNode.dom = newDom;\n        replaceChild(dom.parentNode, newDom, dom);\n        return newDom;\n    }\n    vNode.dom = dom;\n    if (children) {\n        hydrateChildren(children, dom, lifecycle, context, isSVG);\n    }\n    var hasControlledValue = false;\n    if (!(flags & 2 /* HtmlElement */)) {\n        hasControlledValue = processElement(flags, vNode, dom, false);\n    }\n    if (props) {\n        for (var prop in props) {\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\n        }\n    }\n    if (events) {\n        for (var name in events) {\n            patchEvent(name, null, events[name], dom);\n        }\n    }\n    if (ref) {\n        mountRef(dom, ref, lifecycle);\n    }\n    return dom;\n}\nfunction hydrateChildren(children, parentDom, lifecycle, context, isSVG) {\n    normalizeChildNodes(parentDom);\n    var dom = parentDom.firstChild;\n    if (isArray(children)) {\n        for (var i = 0, len = children.length; i < len; i++) {\n            var child = children[i];\n            if (!isNull(child) && isObject(child)) {\n                if (dom) {\n                    dom = hydrate(child, dom, lifecycle, context, isSVG);\n                    dom = dom.nextSibling;\n                }\n                else {\n                    mount(child, parentDom, lifecycle, context, isSVG);\n                }\n            }\n        }\n    }\n    else if (isStringOrNumber(children)) {\n        if (dom && dom.nodeType === 3) {\n            if (dom.nodeValue !== children) {\n                dom.nodeValue = children;\n            }\n        }\n        else if (children) {\n            parentDom.textContent = children;\n        }\n        dom = dom.nextSibling;\n    }\n    else if (isObject(children)) {\n        hydrate(children, dom, lifecycle, context, isSVG);\n        dom = dom.nextSibling;\n    }\n    // clear any other DOM nodes, there should be only a single entry for the root\n    while (dom) {\n        var nextSibling = dom.nextSibling;\n        parentDom.removeChild(dom);\n        dom = nextSibling;\n    }\n}\nfunction hydrateText(vNode, dom) {\n    if (dom.nodeType !== 3) {\n        var newDom = mountText(vNode, null);\n        vNode.dom = newDom;\n        replaceChild(dom.parentNode, newDom, dom);\n        return newDom;\n    }\n    var text = vNode.children;\n    if (dom.nodeValue !== text) {\n        dom.nodeValue = text;\n    }\n    vNode.dom = dom;\n    return dom;\n}\nfunction hydrateVoid(vNode, dom) {\n    vNode.dom = dom;\n    return dom;\n}\nfunction hydrate(vNode, dom, lifecycle, context, isSVG) {\n    var flags = vNode.flags;\n    if (flags & 28 /* Component */) {\n        return hydrateComponent(vNode, dom, lifecycle, context, isSVG, flags & 4 /* ComponentClass */);\n    }\n    else if (flags & 3970 /* Element */) {\n        return hydrateElement(vNode, dom, lifecycle, context, isSVG);\n    }\n    else if (flags & 1 /* Text */) {\n        return hydrateText(vNode, dom);\n    }\n    else if (flags & 4096 /* Void */) {\n        return hydrateVoid(vNode, dom);\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError((\"hydrate() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\n        }\n        throwError();\n    }\n}\nfunction hydrateRoot(input, parentDom, lifecycle) {\n    var dom = parentDom && parentDom.firstChild;\n    if (dom) {\n        hydrate(input, dom, lifecycle, EMPTY_OBJ, false);\n        dom = parentDom.firstChild;\n        // clear any other DOM nodes, there should be only a single entry for the root\n        while (dom = dom.nextSibling) {\n            parentDom.removeChild(dom);\n        }\n        return true;\n    }\n    return false;\n}\n\n// rather than use a Map, like we did before, we can use an array here\n// given there shouldn't be THAT many roots on the page, the difference\n// in performance is huge: https://esbench.com/bench/5802a691330ab09900a1a2da\nvar roots = [];\nvar componentToDOMNodeMap = new Map();\noptions.roots = roots;\nfunction findDOMNode(ref) {\n    if (!options.findDOMNodeEnabled) {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('findDOMNode() has been disabled, use Inferno.options.findDOMNodeEnabled = true; enabled findDOMNode(). Warning this can significantly impact performance!');\n        }\n        throwError();\n    }\n    var dom = ref && ref.nodeType ? ref : null;\n    return componentToDOMNodeMap.get(ref) || dom;\n}\nfunction getRoot(dom) {\n    for (var i = 0, len = roots.length; i < len; i++) {\n        var root = roots[i];\n        if (root.dom === dom) {\n            return root;\n        }\n    }\n    return null;\n}\nfunction setRoot(dom, input, lifecycle) {\n    var root = {\n        dom: dom,\n        input: input,\n        lifecycle: lifecycle\n    };\n    roots.push(root);\n    return root;\n}\nfunction removeRoot(root) {\n    for (var i = 0, len = roots.length; i < len; i++) {\n        if (roots[i] === root) {\n            roots.splice(i, 1);\n            return;\n        }\n    }\n}\nif (process.env.NODE_ENV !== 'production') {\n    if (isBrowser && document.body === null) {\n        warning('Inferno warning: you cannot initialize inferno without \"document.body\". Wait on \"DOMContentLoaded\" event, add script to bottom of body, or use async/defer attributes on script tag.');\n    }\n}\nvar documentBody = isBrowser ? document.body : null;\nfunction render(input, parentDom) {\n    if (documentBody === parentDom) {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('you cannot render() to the \"document.body\". Use an empty element as a container instead.');\n        }\n        throwError();\n    }\n    if (input === NO_OP) {\n        return;\n    }\n    var root = getRoot(parentDom);\n    if (isNull(root)) {\n        var lifecycle = new Lifecycle();\n        if (!isInvalid(input)) {\n            if (input.dom) {\n                input = cloneVNode(input);\n            }\n            if (!hydrateRoot(input, parentDom, lifecycle)) {\n                mount(input, parentDom, lifecycle, EMPTY_OBJ, false);\n            }\n            root = setRoot(parentDom, input, lifecycle);\n            lifecycle.trigger();\n        }\n    }\n    else {\n        var lifecycle$1 = root.lifecycle;\n        lifecycle$1.listeners = [];\n        if (isNullOrUndef(input)) {\n            unmount(root.input, parentDom, lifecycle$1, false, false);\n            removeRoot(root);\n        }\n        else {\n            if (input.dom) {\n                input = cloneVNode(input);\n            }\n            patch(root.input, input, parentDom, lifecycle$1, EMPTY_OBJ, false, false);\n        }\n        lifecycle$1.trigger();\n        root.input = input;\n    }\n    if (root) {\n        var rootInput = root.input;\n        if (rootInput && (rootInput.flags & 28 /* Component */)) {\n            return rootInput.children;\n        }\n    }\n}\nfunction createRenderer(parentDom) {\n    return function renderer(lastInput, nextInput) {\n        if (!parentDom) {\n            parentDom = lastInput;\n        }\n        render(nextInput, parentDom);\n    };\n}\n\nif (process.env.NODE_ENV !== 'production') {\n    var testFunc = function testFn() { };\n    if ((testFunc.name || testFunc.toString()).indexOf('testFn') === -1) {\n        warning(('It looks like you\\'re using a minified copy of the development build ' +\n            'of Inferno. When deploying Inferno apps to production, make sure to use ' +\n            'the production build which skips development warnings and is faster. ' +\n            'See http://infernojs.org for more details.'));\n    }\n}\n// This will be replaced by rollup\nvar version = '1.3.0-rc.8';\n// we duplicate it so it plays nicely with different module loading systems\nvar index = {\n    linkEvent: linkEvent,\n    // core shapes\n    createVNode: createVNode,\n    // cloning\n    cloneVNode: cloneVNode,\n    // used to shared common items between Inferno libs\n    NO_OP: NO_OP,\n    EMPTY_OBJ: EMPTY_OBJ,\n    // DOM\n    render: render,\n    findDOMNode: findDOMNode,\n    createRenderer: createRenderer,\n    options: options,\n    version: version\n};\n\nexports.version = version;\nexports['default'] = index;\nexports.linkEvent = linkEvent;\nexports.createVNode = createVNode;\nexports.cloneVNode = cloneVNode;\nexports.NO_OP = NO_OP;\nexports.EMPTY_OBJ = EMPTY_OBJ;\nexports.render = render;\nexports.findDOMNode = findDOMNode;\nexports.createRenderer = createRenderer;\nexports.options = options;\nexports.internal_isUnitlessNumber = isUnitlessNumber;\nexports.internal_normalize = normalize;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inferno/dist/inferno.node.js\n// module id = 0\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/~/node-libs-browser/~/process/browser.js\n// module id = 1\n// module chunks = 0","\n/*!\n * inferno-component v1.3.0-rc.8\n * (c) 2017 Dominic Gannaway'\n * Released under the MIT License.\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('inferno')) :\n\ttypeof define === 'function' && define.amd ? define(['inferno'], factory) :\n\t(global['inferno-component'] = factory(global.Inferno));\n}(this, (function (inferno) { 'use strict';\n\nvar NO_OP = '$NO_OP';\nvar ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';\nvar isBrowser = typeof window !== 'undefined' && window.document;\n\n// this is MUCH faster than .constructor === Array and instanceof Array\n// in Node 7 and the later versions of V8, slower in older versions though\nvar isArray = Array.isArray;\n\nfunction isStringOrNumber(obj) {\n    var type = typeof obj;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(obj) {\n    return isUndefined(obj) || isNull(obj);\n}\nfunction isInvalid(obj) {\n    return isNull(obj) || obj === false || isTrue(obj) || isUndefined(obj);\n}\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\n\n\n\nfunction isNull(obj) {\n    return obj === null;\n}\nfunction isTrue(obj) {\n    return obj === true;\n}\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\n\nfunction throwError(message) {\n    if (!message) {\n        message = ERROR_MSG;\n    }\n    throw new Error((\"Inferno Error: \" + message));\n}\n\nfunction Lifecycle() {\n    this.listeners = [];\n}\nLifecycle.prototype.addListener = function addListener(callback) {\n    this.listeners.push(callback);\n};\nLifecycle.prototype.trigger = function trigger() {\n    var this$1 = this;\n\n    for (var i = 0, len = this.listeners.length; i < len; i++) {\n        this$1.listeners[i]();\n    }\n};\n\n// Make sure u use EMPTY_OBJ from 'inferno', otherwise it'll be a different reference\nvar noOp = ERROR_MSG;\nif (process.env.NODE_ENV !== 'production') {\n    noOp = 'Inferno Error: Can only update a mounted or mounting component. This usually means you called setState() or forceUpdate() on an unmounted component. This is a no-op.';\n}\nvar componentCallbackQueue = new Map();\n// when a components root VNode is also a component, we can run into issues\n// this will recursively look for vNode.parentNode if the VNode is a component\nfunction updateParentComponentVNodes(vNode, dom) {\n    if (vNode.flags & 28 /* Component */) {\n        var parentVNode = vNode.parentVNode;\n        if (parentVNode) {\n            parentVNode.dom = dom;\n            updateParentComponentVNodes(parentVNode, dom);\n        }\n    }\n}\n// this is in shapes too, but we don't want to import from shapes as it will pull in a duplicate of createVNode\nfunction createVoidVNode() {\n    return inferno.createVNode(4096 /* Void */);\n}\nfunction createTextVNode(text) {\n    return inferno.createVNode(1 /* Text */, null, null, text);\n}\nfunction addToQueue(component, force, callback) {\n    // TODO this function needs to be revised and improved on\n    var queue = componentCallbackQueue.get(component);\n    if (!queue) {\n        queue = [];\n        componentCallbackQueue.set(component, queue);\n        Promise.resolve().then(function () {\n            componentCallbackQueue.delete(component);\n            applyState(component, force, function () {\n                for (var i = 0, len = queue.length; i < len; i++) {\n                    queue[i]();\n                }\n            });\n        });\n    }\n    if (callback) {\n        queue.push(callback);\n    }\n}\nfunction queueStateChanges(component, newState, callback, sync) {\n    if (isFunction(newState)) {\n        newState = newState(component.state, component.props, component.context);\n    }\n    for (var stateKey in newState) {\n        component._pendingState[stateKey] = newState[stateKey];\n    }\n    if (!component._pendingSetState && isBrowser && !(sync && component._blockRender)) {\n        if (sync || component._blockRender) {\n            component._pendingSetState = true;\n            applyState(component, false, callback);\n        }\n        else {\n            addToQueue(component, false, callback);\n        }\n    }\n    else {\n        Object.assign(component.state, component._pendingState);\n        component._pendingState = {};\n    }\n}\nfunction applyState(component, force, callback) {\n    if ((!component._deferSetState || force) && !component._blockRender && !component._unmounted) {\n        component._pendingSetState = false;\n        var pendingState = component._pendingState;\n        var prevState = component.state;\n        var nextState = Object.assign({}, prevState, pendingState);\n        var props = component.props;\n        var context = component.context;\n        component._pendingState = {};\n        var nextInput = component._updateComponent(prevState, nextState, props, props, context, force, true);\n        var didUpdate = true;\n        if (isInvalid(nextInput)) {\n            nextInput = createVoidVNode();\n        }\n        else if (nextInput === NO_OP) {\n            nextInput = component._lastInput;\n            didUpdate = false;\n        }\n        else if (isStringOrNumber(nextInput)) {\n            nextInput = createTextVNode(nextInput);\n        }\n        else if (isArray(nextInput)) {\n            if (process.env.NODE_ENV !== 'production') {\n                throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n            }\n            throwError();\n        }\n        var lastInput = component._lastInput;\n        var vNode = component._vNode;\n        var parentDom = (lastInput.dom && lastInput.dom.parentNode) || (lastInput.dom = vNode.dom);\n        component._lastInput = nextInput;\n        if (didUpdate) {\n            var subLifecycle = component._lifecycle;\n            if (!subLifecycle) {\n                subLifecycle = new Lifecycle();\n            }\n            else {\n                subLifecycle.listeners = [];\n            }\n            component._lifecycle = subLifecycle;\n            var childContext = component.getChildContext();\n            if (isNullOrUndef(childContext)) {\n                childContext = component._childContext;\n            }\n            else {\n                childContext = Object.assign({}, context, component._childContext, childContext);\n            }\n            component._patch(lastInput, nextInput, parentDom, subLifecycle, childContext, component._isSVG, false);\n            subLifecycle.trigger();\n            component.componentDidUpdate(props, prevState);\n            inferno.options.afterUpdate && inferno.options.afterUpdate(vNode);\n        }\n        var dom = vNode.dom = nextInput.dom;\n        var componentToDOMNodeMap = component._componentToDOMNodeMap;\n        componentToDOMNodeMap && componentToDOMNodeMap.set(component, nextInput.dom);\n        updateParentComponentVNodes(vNode, dom);\n        if (!isNullOrUndef(callback)) {\n            callback();\n        }\n    }\n    else if (!isNullOrUndef(callback)) {\n        callback();\n    }\n}\nvar Component = function Component(props, context) {\n    this.state = {};\n    this.refs = {};\n    this._blockRender = false;\n    this._ignoreSetState = false;\n    this._blockSetState = false;\n    this._deferSetState = false;\n    this._pendingSetState = false;\n    this._syncSetState = true;\n    this._pendingState = {};\n    this._lastInput = null;\n    this._vNode = null;\n    this._unmounted = true;\n    this._lifecycle = null;\n    this._childContext = null;\n    this._patch = null;\n    this._isSVG = false;\n    this._componentToDOMNodeMap = null;\n    /** @type {object} */\n    this.props = props || inferno.EMPTY_OBJ;\n    /** @type {object} */\n    this.context = context || inferno.EMPTY_OBJ; // context should not be mutable\n};\nComponent.prototype.render = function render (nextProps, nextState, nextContext) {\n};\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\n    if (this._unmounted) {\n        return;\n    }\n    isBrowser && applyState(this, true, callback);\n};\nComponent.prototype.setState = function setState (newState, callback) {\n    if (this._unmounted) {\n        return;\n    }\n    if (!this._blockSetState) {\n        if (!this._ignoreSetState) {\n            queueStateChanges(this, newState, callback, this._syncSetState);\n        }\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('cannot update state via setState() in componentWillUpdate().');\n        }\n        throwError();\n    }\n};\nComponent.prototype.setStateSync = function setStateSync (newState) {\n    if (this._unmounted) {\n        return;\n    }\n    if (!this._blockSetState) {\n        if (!this._ignoreSetState) {\n            queueStateChanges(this, newState, null, true);\n        }\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('cannot update state via setState() in componentWillUpdate().');\n        }\n        throwError();\n    }\n};\nComponent.prototype.componentWillMount = function componentWillMount () {\n};\nComponent.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState, prevContext) {\n};\nComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState, context) {\n    return true;\n};\nComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps (nextProps, context) {\n};\nComponent.prototype.componentWillUpdate = function componentWillUpdate (nextProps, nextState, nextContext) {\n};\nComponent.prototype.getChildContext = function getChildContext () {\n};\nComponent.prototype._updateComponent = function _updateComponent (prevState, nextState, prevProps, nextProps, context, force, fromSetState) {\n    if (this._unmounted === true) {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError(noOp);\n        }\n        throwError();\n    }\n    if ((prevProps !== nextProps || nextProps === inferno.EMPTY_OBJ) || prevState !== nextState || force) {\n        if (prevProps !== nextProps || nextProps === inferno.EMPTY_OBJ) {\n            if (!fromSetState) {\n                this._blockRender = true;\n                this.componentWillReceiveProps(nextProps, context);\n                this._blockRender = false;\n            }\n            if (this._pendingSetState) {\n                nextState = Object.assign({}, nextState, this._pendingState);\n                this._pendingSetState = false;\n                this._pendingState = {};\n            }\n        }\n        var shouldUpdate = this.shouldComponentUpdate(nextProps, nextState, context);\n        if (shouldUpdate || force) {\n            this._blockSetState = true;\n            this.componentWillUpdate(nextProps, nextState, context);\n            this._blockSetState = false;\n            this.props = nextProps;\n            this.state = nextState;\n            this.context = context;\n            inferno.options.beforeRender && inferno.options.beforeRender(this);\n            var render = this.render(nextProps, nextState, context);\n            inferno.options.afterRender && inferno.options.afterRender(this);\n            return render;\n        }\n        else {\n            this.props = nextProps;\n            this.state = nextState;\n            this.context = context;\n        }\n    }\n    return NO_OP;\n};\n\nreturn Component;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inferno-component/dist/inferno-component.node.js\n// module id = 2\n// module chunks = 0","\r\nimport Inferno from 'inferno';\r\nimport Component from 'inferno-component';\r\n\r\nconsole.log(Component);\r\n\r\nexport class MyComp extends Component<{},{}> {\r\n    public render() {\r\n        return 'moo';\r\n    }\r\n}\r\n\r\nInferno.render('hello world', document.querySelector('#viewContainer'));\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts"],"sourceRoot":""}